{"name":"Fs2","tagline":"File Structures 2 - Memory Mapped File Structures for Go (golang)","body":"# fs2 - File Structures 2\r\n\r\nby Tim Henderson (tadh@case.edu)\r\n\r\nLicensed under the GNU GPL version 3 or at your option any later version. If you\r\nneed another licensing option please contact me directly.\r\n\r\n### What is this?\r\n\r\n1. A [B+ Tree](#b-tree) implementation\r\n2. A [list](#mmlist) implemenation supporting O(1) Append, Pop, Get and Set operations.\r\n3. A [command](#fs2-generic) to generate type specific wrappers around the above\r\n   structures. It's generic, in Go, kinda.\r\n4. A [platform](#fmap) for implementing memory mapped high performance file\r\n   structures in Go.\r\n\r\n### Why did you make this?\r\n\r\nIn my academic research some of the algorithms I work on (such as frequent\r\nsubgraph mining) have exponential characteristics in their memory usage. In\r\norder to run these algorithms on larger data sets they need to be able to\r\ntransparently cache less popular parts of the data to disk. However, in general\r\nit is best to keep as much data in memory as possible.\r\n\r\nOf course, there are many options for such data stores. I could have used a off\r\nthe shelf database, however I also want to explore ways to achieve higher\r\nperformance than those solutions offer.\r\n\r\n#### Have you worked on this type of system before?\r\n\r\nI have! In the golang world I believe I was the first to implement a disk backed\r\nB+ Tree. Here is an [early\r\ncommit](https://github.com/timtadh/file-structures/commit/aedff4a077e16eb87e2d0f8ed4bc676debf7c572)\r\nfrom  my [file-structures\r\nrepository](https://github.com/timtadh/file-structures). Note the date: February\r\n21, 2010. Go was made public in November of 2009 (the first weekly was November\r\n06, 2009). I started work on the B+ Tree in January of 2010.\r\n\r\nThis particular experiment is a follow up to my work in the file-structures\r\nrepository. I have used those structures successfully many times but I want to\r\nexperiment with new ways of doing things to achieve better results. Besides my\r\ndisk backed versions of these structures you can also find good implementations\r\nof in memory version in my\r\n[data-structures repository](https://github.com/timtadh/data-structures).\r\n\r\n## B+ Tree\r\n\r\n[docs](https://godoc.org/github.com/timtadh/fs2/bptree)\r\n\r\nThis is a disk backed low level \"key-value store\". The closest thing similar to\r\nwhat it offers is [Bolt DB](https://github.com/boltdb/bolt).  My [blog\r\npost](http://hackthology.com/lessons-learned-while-implementing-a-btree.html)\r\nis a great place to start to learn more about the ubiquitous B+ Tree.\r\n\r\n### Features\r\n\r\n1. Variable length size key or fixed sized keys. Fixed sized keys should be kept\r\n   relatively short, less than 1024 bytes (the shorter the better). Variable\r\n   length keys can be up to 2^31 - 1 bytes long.\r\n\r\n2. Variable length values or fixed sized values. Fixed sized values should also\r\n   be kept short, less than 1024 bytes. Variable length values can be up to\r\n   2^31 - 1 bytes long.\r\n\r\n3. Duplicate key support. Duplicates are kept out of the index and only occur in\r\n   the leaves.\r\n\r\n4. Data is only written to disk when you tell it (or when need due to OS level\r\n   page management).\r\n\r\n5. Simple (but low level) interface.\r\n\r\n6. Can operate in either a anonymous memory map or in a file backed memory map.\r\n   If you plan to have a very large tree (even one that never needs to be\r\n   persisted) it is recommend you use a file backed memory map. The OS treats\r\n   pages in the file cache different than pages which are not backed by files.\r\n\r\n7. The command `fs2-generic` can generate a wrapper specialized to your data\r\n   type. Typing saved! To use `go install github.com/timtadh/fs2/fs2-generic`.\r\n   Get help with `fs2-generic --help`\r\n\r\n### Limitations\r\n\r\n1. Not thread safe and therefore no transactions which you only need with\r\n   multiple threads.\r\n\r\n2. Maximum fixed key/value size is ~1350 bytes.\r\n\r\n3. Maximum variable length key/value size is 2^31 - 1\r\n\r\n4. This is not a database. You could make it into a database or build a database\r\n   on top of it.\r\n\r\n### Quick Start\r\n\r\n[usage docs on godoc](https://godoc.org/github.com/timtadh/fs2/bptree#BpTree)\r\n\r\nImporting\r\n\r\n```go\r\nimport (\r\n\t\"github.com/timtadh/fs2/bptree\"\r\n\t\"github.com/timtadh/fs2/fmap\"\r\n)\r\n```\r\n\r\nCreating a new B+ Tree (fixed key size, variable length value size).\r\n\r\n```go\r\nbf, err := fmap.CreateBlockFile(\"/path/to/file\")\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\ndefer bf.Close()\r\nbpt, err := bptree.New(bf, 8, -1)\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\n// do stuff with bpt\r\n```\r\n\r\nOpening a B+ Tree\r\n\r\n```go\r\nbf, err := fmap.OpenBlockFile(\"/path/to/file\")\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\ndefer bf.Close()\r\nbpt, err := bptree.Open(bf)\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\n// do stuff with bpt\r\n```\r\n\r\nAdd a key/value pair. Note, since this is low level you have to serialize your\r\nkeys and values. The length of the []byte representing the key must exactly\r\nmatch the key size of the B+ Tree. You can find out what that was set to by\r\ncalled `bpt.KeySize()`\r\n\r\n```go\r\nimport (\r\n\t\"encoding/binary\"\r\n)\r\n\r\nvar key uint64 = 12\r\nvalue := \"hello world\"\r\nkBytes := make([]byte, 8)\r\nbinary.PutUvarint(kBytes, key)\r\nerr := bpt.Add(kBytes, []byte(value))\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\n```\r\n\r\nAs you can see it can be a little verbose to serialize and de-serialize your\r\nkeys and values. So be sure to wrap that up in utility functions or even to wrap\r\nthe interface of the B+ Tree so that client code does not have to think about\r\nit.\r\n\r\nSince a B+Tree is a \"multi-map\" meaning there may be more than one value per\r\nkey. There is no \"Get\" method. To retrieve the values associated with a key use\r\nthe `Find` method.\r\n\r\n```go\r\n{\r\n\tvar key, value []byte\r\n\tkvi, err := bpt.Find(kBytes)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tfor key, value, err, kvi = kvi(); kvi != nil; key, value, err, kvi = kvi() {\r\n\t\t// do stuff with the keys and values\r\n\t}\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n}\r\n```\r\n\r\nThat interface is easy to misuse if you do not check the error values as show in\r\nthe example above. An easier interface is provided for all of the iterators\r\n(Range, Find, Keys, Values, Iterate) called the Do interface.\r\n\r\n```go\r\nerr = bpt.DoFind(kBytes, func(key, value []byte) error {\r\n\t// do stuff with the keys and values\r\n\treturn nil\r\n})\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\n```\r\n\r\nIt is recommended that you always use the Do\\* interfaces. The other is provided\r\nif the cost of extra method calls is too high.\r\n\r\nRemoval is also slightly more complicated due to the duplicate keys.  This\r\nexample will remove all key/value pairs associated with the given key:\r\n\r\n```go\r\nerr = bpt.Remove(kBytes, func(value []byte) bool {\r\n\treturn true\r\n})\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\n```\r\n\r\nto remove just the one I added earlier do:\r\n\r\n```go\r\nerr = bpt.Remove(kBytes, func(v []byte) bool {\r\n\treturn bytes.Equal(v, []byte(value))\r\n})\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\n```\r\n\r\nThat wraps up the basic usage. If you want to ensure that the bytes you have\r\nwritten are in fact on disk you have 2 options\r\n\r\n1. call bf.Sync() - Note this uses the async mmap interface under the hood. The\r\n   bytes are not guaranteed to hit the disk after this returns but they will go\r\n   there soon.\r\n\r\n2. call bf.Close()\r\n\r\n\r\n## MMList\r\n\r\n[docs](https://godoc.org/github.com/timtadh/fs2/mmlist)\r\n\r\nA Memory Mapped List. This list works more like a stack and less like a queue.\r\nIt is not a good thing to build a job queue on. It is a good thing to build a\r\nlarge set of items which can be efficiently randomly sampled. It uses the same\r\n`varchar` system that the B+Tree uses so it can store variably sized items up to\r\n2^31 - 1 bytes long.\r\n\r\nOperations\r\n\r\n1. `Size` O(1)\r\n2. `Append` O(1)\r\n3. `Pop` O(1)\r\n4. `Get` O(1)\r\n5. `Set` O(1)\r\n6. `Swap` O(1)\r\n7. `SwapDelete` O(1)\r\n\r\nI will consider implementing a `Delete` method. However, it will be `O(n)` since\r\nthis is implemented a bit like an `ArrayList` under the hood. The actual way it\r\nworks is there is a B+Tree which indexes to list index blocks. The list index\r\nblocks hold pointers (511 of them) to varchar locations. I considered having a\r\nrestricted 2 level index but that would have limited the size of the list to a\r\nmaximum of ~1 billion items which was uncomfortably small to me. In the future\r\nthe implementation may change to use something more like an ISAM index which\r\nwill be a bit more compact for this use case.\r\n\r\n### Quickstart\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"binary\"\r\n\t\"log\"\r\n)\r\n\r\nimport (\r\n\t\"github.com/timtadh/fs2/fmap\"\r\n\t\"github.com/timtadh/fs2/mmlist\"\r\n)\r\n\r\nfunc main() {\r\n\tfile, err := fmap.CreateBlockFile(\"/tmp/file\")\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tdefer file.Close()\r\n\tlist, err := mmlist.New(file)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tidx, err := list.Append([]byte(\"hello\"))\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tif d, err := list.Get(idx); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t} else if !bytes.Equal([]byte(\"hello\"), d) {\r\n\t\tlog.Fatal(\"bytes where not hello\")\r\n\t}\r\n\tif err := list.Set(idx, \"bye!\"); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tif d, err := list.Get(idx); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t} else if !bytes.Equal([]byte(\"bye!\"), d) {\r\n\t\tlog.Fatal(\"bytes where not bye!\")\r\n\t}\r\n\tif d, err := list.Pop(); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t} else if !bytes.Equal([]byte(\"bye!\"), d) {\r\n\t\tlog.Fatal(\"bytes where not bye!\")\r\n\t}\r\n}\r\n```\r\n\r\n## `fs2-generic`\r\n\r\nA command to generate type specialized wrappers around fs2 structures.\r\n\r\nSince Go does not support generics and is not going to support generics anytime\r\nsoon, this program will produce a wrapper specialized to the supplied types. It\r\nis essentially manually implementing type specialized generics in a very limited\r\nform.  All fs2 structures operate on sequences of bytes, aka `[]byte`, because\r\nthey memory mapped and file backed structures. Therefore, the supplied types\r\nmust be serializable to be used as keys and values in an fs2 structure.\r\n\r\n### How to install\r\n\r\nAssuming you already have the code downloaded and in your GOPATH just run:\r\n\r\n    $ go install github.com/timtadh/fs2/fs2-generic\r\n\r\n#### How to generate a wrapper for the B+ Tree\r\n\r\n    $ fs2-generic \\\r\n        --output=src/output/package/file.go \\\r\n        --package-name=package \\\r\n        bptree \\\r\n            --key-type=my/package/name/Type \\\r\n            --key-serializer=my/package/name/Func \\\r\n            --key-deserializer=my/package/name/Func \\\r\n            --value-type=my/package/name/Type \\\r\n            --value-serializer=my/package/name/Func \\\r\n            --value-deserializer=my/package/name/Func\r\n\r\n#### How to generate a wrapper for the MMList\r\n\r\n    $ fs2-generic \\\r\n        --output=src/output/package/file.go \\\r\n        --package-name=package \\\r\n        mmlist \\\r\n            --item-type=my/package/name/Type \\\r\n            --item-serializer=my/package/name/Func \\\r\n            --item-deserializer=my/package/name/Func\r\n\r\n#### Variations\r\n\r\nSupplying a pointer type:\r\n\r\n    --key-type=*my/package/name/Type\r\n    --value-type=*my/package/name/Type\r\n\r\nSerializer Type Signature (let T be a type parameter)\r\n\r\n    func(T) ([]byte)\r\n\r\nDeserializer Type Signature (let T be a type parameter)\r\n\r\n    func([]byte) T\r\n\r\nFixed sized types can have their sizes specified with\r\n\r\n    --key-size=<# of bytes>\r\n    --value-size=<# of bytes>\r\n\r\nIf the generated file is going into the same package that the types and\r\nfunction are declared in one should drop the package specifiers\r\n\r\n    $ fs2-generic \\\r\n        --output=src/output/package/file.go \\\r\n        --package-name=package \\\r\n        bptree \\\r\n            --key-type=KeyType \\\r\n            --key-serializer=SerializeKey \\\r\n            --key-deserializer=DeserializeKey \\\r\n            --value-type=ValueType \\\r\n            --value-serializer=SerializeValue \\\r\n            --value-deserializer=DeserializeValue\r\n\r\nIf `nil` is not a valid \"empty\" value for your type (for instance it is an\r\ninteger, a float, or a struct value) then your must supply a valid \"empty\"\r\nvalue. Here is an example of a tree with int32 keys and float64 values:\r\n\r\n    $ fs2-generic \\\r\n        --output=src/output/package/file.go \\\r\n        --package-name=package \\\r\n        bptree \\\r\n            --key-type=int32 \\\r\n            --key-size=4 \\\r\n            --key-empty=0 \\\r\n            --key-serializer=SerializeInt32 \\\r\n            --key-deserializer=DeserializeInt32 \\\r\n            --value-type=float64 \\\r\n            --value-size=8 \\\r\n            --value-empty=0.0 \\\r\n            --value-serializer=SerializeFloat64 \\\r\n            --value-deserializer=DeserializeFloat64\r\n\r\n### Using with `go generate`\r\n\r\nThe fs2-generic command can be used on conjunction with `go generate`. To do so\r\nsimply create a `.go` file in the package where the generated code should live.\r\nFor example, let's pretend that we want to create a B+Tree with 3 dimension\r\ninteger points as keys and float64's as values. Lets create a package structure\r\nfor that (assuming you are in the root of your $GOPATH)\r\n\r\n    mkdir ./src/edu/cwru/eecs/pointbptree/\r\n    touch ./src/edu/cwru/eecs/pointbptree/types.go\r\n\r\n`types.go` should then have the point defined + functions for serialization.\r\nBelow is the full example. Note the top line specifies how to generate the file\r\n`./src/edu/cwru/eecs/pointbptree/wrapper.go`. To generate it run `go generate\r\nedu/cwru/eecs/pointbptree`.\r\n\r\n```go\r\n//go:generate fs2-generic --output=wrapper.go --package-name=pointbptree bptree --key-type=*Point --key-size=12 --key-empty=nil --key-serializer=SerializePoint --key-deserializer=DeserializePoint --value-type=float64 --value-size=8 --value-empty=0.0 --value-serializer=SerializeFloat64 --value-deserializer=DeserializeFloat64\r\npackage pointbptree\r\n\r\nimport (\r\n\t\"encoding/binary\"\r\n\t\"math\"\r\n)\r\n\r\ntype Point struct {\r\n\tX, Y, Z int32\r\n}\r\n\r\nfunc SerializePoint(p *Point) []byte {\r\n\tbytes := make([]byte, 4*3)\r\n\tbinary.BigEndian.PutUint32(bytes[0:04], uint32(p.X))\r\n\tbinary.BigEndian.PutUint32(bytes[4:08], uint32(p.Y))\r\n\tbinary.BigEndian.PutUint32(bytes[8:12], uint32(p.Z))\r\n\treturn bytes\r\n}\r\n\r\nfunc DeserializePoint(bytes []byte) *Point {\r\n\treturn &Point{\r\n\t\tX: int32(binary.BigEndian.Uint32(bytes[0:04])),\r\n\t\tY: int32(binary.BigEndian.Uint32(bytes[4:08])),\r\n\t\tZ: int32(binary.BigEndian.Uint32(bytes[8:12])),\r\n\t}\r\n}\r\n\r\nfunc SerializeFloat64(f float64) []byte {\r\n\tbytes := make([]byte, 8)\r\n\tbinary.BigEndian.PutUint64(bytes, math.Float64bits(f))\r\n\treturn bytes\r\n}\r\n\r\nfunc DeserializeFloat64(bytes []byte) float64 {\r\n\treturn math.Float64frombits(binary.BigEndian.Uint64(bytes))\r\n}\r\n```\r\n\r\n\r\n## FMap\r\n\r\n[docs](https://godoc.org/github.com/timtadh/fs2/fmap)\r\n\r\nFMap provides a block oriented interface for implementing memory mapped file\r\nstructures. It is block oriented because memory mapped structures **should** be\r\nblock aligned. By making the interface block oriented, the programmer is forced\r\nto write the structures in a block oriented fashion. I use it with\r\n[fs2/slice](https://godoc.org/github.com/timtadh/fs2/slice) which provides a\r\nsimple way to cast []byte to other types of pointers. You can accomplish a\r\nsimilar thing with just using the `reflect` package but you might find\r\n`fs2/slice` more convenient.\r\n\r\nFMap provides an interface for creating both anonymous and file backed memory\r\nmaps. It supports resizing the memory maps dynamically via allocation and free\r\nmethods. Note, when an allocation occurs the underlying file and memory map\r\n**may** resize using `mremap` with the flag `MREMAP_MAYMOVE`. So don't let\r\npointers escape your memory map! Keep everything as file offsets and be happy!\r\n\r\n## Memory Mapped IO versus Read/Write\r\n\r\nA key motivation of this work is to explore memory mapped IO versus a read/write\r\ninterface in the context of Go. I have two hypotheses:\r\n\r\n1. The operating system is good at page management generally. While, we know\r\n   more about how to manage the structure of B+Trees, VarChar stores, and Linear\r\n   Hash tables than the OS there is no indication that from Go you can achieve\r\n   better performance. Therefore, I hypothesize that leaving it to the OS will\r\n   lead to a smaller working set and a faster data structure in general.\r\n\r\n2. You can make Memory Mapping performant in Go. There are many challenges here.\r\n   The biggest of which is that there are no dynamically size array TYPES in go.\r\n   The size of the array is part of the type, you have to use slices. This\r\n   creates complications when hooking up structures which contain slices to mmap\r\n   allocated blocks of memory. I hypothesize that this repository can achieve\r\n   good (enough) performance here.\r\n\r\nIn my past experience using the read/write interface I have encountered two\r\nchallenges:\r\n\r\n1. When using the read/write interface one needs to block and cache management.\r\n   In theory databases which bypass the OS cache management get better\r\n   performance. In practice, there are challenges achieving this from a garbage\r\n   collected language.\r\n\r\n2. Buffer management is a related problem. In the past I have relied on Go's\r\n   built in memory management scheme. This often become a bottle neck. To solve\r\n   this problem, one must implement custom allocators and buffer management\r\n   subsystems.\r\n\r\nMemory mapped IO avoids both of these problems by delegating them to the\r\noperating system. If the OS does a good job, then this system will perform well.\r\nIf it does a bad job it will perform poorly. The reason why systems such as\r\nOracle circumvent all OS level functions for page management is the designers\r\nbelieve: a) they can do it better, and b) it provides consistent performance\r\nacross platforms.\r\n\r\nMemory mapped IO in Go has several challenges.\r\n\r\n1. You have to subvert type and memory safety.\r\n\r\n2. There is no dynamically sized arrays. Therefore, everything has to use\r\n   slices. This means that you can't just point a `struct` at a memory mapped\r\n   block and expect it work if it has slices in it. Instead, some book keeping\r\n   needs to be done to hook up the slices properly. This adds overhead.\r\n\r\nThe results so far:\r\n\r\n1. It can be done\r\n\r\n2. Integrating (partial) runtime checking for safety can be achieved through the\r\n   use of the \"do\" interface.\r\n\r\n3. The performance numbers look like they are as good or better than the\r\n   Linear Hash table I implemented in my file-structures repository.\r\n\r\n## Related Projects\r\n\r\n1. [file-structures](https://github.com/timtadh/file-structures) - A collection\r\n   of file-structures includes: B+Tree, BTree, Linear Hash Table, VarChar Store.\r\n2. [data-structures](https://github.com/timtadh/data-structures) - A collection\r\n   of in memory data structures. Includes a B+Tree.\r\n3. [boltdb](https://github.com/boltdb/bolt) - a mmap'ed b+ tree based key/value\r\n   store.\r\n4. [goleveldb](https://github.com/syndtr/goleveldb) - another database written\r\n   in go\r\n5. [cznic/b](https://github.com/cznic/b) - an in memory b+ tree\r\n6. [xiang90/bplustree](https://github.com/xiang90/bplustree) - an in memory b+\r\n   tree\r\n7. your project here.\r\n\r\n","google":"UA-20145944-2","note":"Don't delete this file! It's used internally to help with page regeneration."}